//
//  HijinnksStyleKit.swift
//  Hijinnks
//
//  Created by Adebayo Ijidakinro on 3/4/17.
//  Copyright Â© 2017 Dephyned. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class HijinnksStyleKit : NSObject {

    //// Cache

    private struct Cache {
        static var imageOfTextLogo: UIImage?
        static var textLogoTargets: [AnyObject]?
    }

    //// Drawing Methods

    public dynamic class func drawTextLogo(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 130, height: 53), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 130, height: 53), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 130, y: resizedFrame.height / 53)


        //// Color Declarations
        let textForeground = UIColor(red: 0.454, green: 0.203, blue: 0.544, alpha: 1.000)

        //// Label Drawing
        let labelRect = CGRect(x: 0, y: -0.46, width: 130, height: 53.46)
        let labelTextContent = "Hijinnks"
        let labelStyle = NSMutableParagraphStyle()
        labelStyle.alignment = .center
        let labelFontAttributes = [NSFontAttributeName: UIFont(name: "QuimbyGubernatorial", size: 30)!, NSForegroundColorAttributeName: textForeground, NSParagraphStyleAttributeName: labelStyle]

        let labelTextHeight: CGFloat = labelTextContent.boundingRect(with: CGSize(width: labelRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: labelFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: labelRect)
        labelTextContent.draw(in: CGRect(x: labelRect.minX, y: labelRect.minY + (labelRect.height - labelTextHeight) / 2, width: labelRect.width, height: labelTextHeight), withAttributes: labelFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawOrView(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 75, height: 75), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 75, height: 75), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 75, y: resizedFrame.height / 75)


        //// Color Declarations
        let fillColor = UIColor(red: 0.189, green: 0.286, blue: 0.607, alpha: 1.000)

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 37.5, y: -0))
        bezierPath.addCurve(to: CGPoint(x: -0, y: 37.5), controlPoint1: CGPoint(x: 16.79, y: -0), controlPoint2: CGPoint(x: -0, y: 16.79))
        bezierPath.addLine(to: CGPoint(x: 9.34, y: 37.5))
        bezierPath.addCurve(to: CGPoint(x: 37.5, y: 9.34), controlPoint1: CGPoint(x: 9.34, y: 21.95), controlPoint2: CGPoint(x: 21.95, y: 9.34))
        bezierPath.addCurve(to: CGPoint(x: 65.66, y: 37.5), controlPoint1: CGPoint(x: 53.05, y: 9.34), controlPoint2: CGPoint(x: 65.66, y: 21.95))
        bezierPath.addCurve(to: CGPoint(x: 37.5, y: 65.66), controlPoint1: CGPoint(x: 65.66, y: 53.05), controlPoint2: CGPoint(x: 53.05, y: 65.66))
        bezierPath.addLine(to: CGPoint(x: 37.41, y: 65.66))
        bezierPath.addLine(to: CGPoint(x: 37.41, y: 75))
        bezierPath.addLine(to: CGPoint(x: 37.5, y: 75))
        bezierPath.addCurve(to: CGPoint(x: 75, y: 37.5), controlPoint1: CGPoint(x: 58.21, y: 75), controlPoint2: CGPoint(x: 75, y: 58.21))
        bezierPath.addCurve(to: CGPoint(x: 37.5, y: -0), controlPoint1: CGPoint(x: 75, y: 16.79), controlPoint2: CGPoint(x: 58.21, y: -0))
        bezierPath.close()
        fillColor.setFill()
        bezierPath.fill()
        
        context.restoreGState()

    }

    public dynamic class func drawMapButton(frame: CGRect = CGRect(x: 0, y: 0, width: 58, height: 58)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let fillColor2 = UIColor(red: 0.427, green: 0.602, blue: 0.820, alpha: 1.000)
        let fillColor3 = UIColor(red: 0.105, green: 0.505, blue: 0.371, alpha: 1.000)


        //// Subframes
        let group: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)


        //// Group
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 1.00000 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.00000 + 0.5)))
        fillColor2.setFill()
        ovalPath.fill()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group.minX + 0.75667 * group.width, y: group.minY + 0.07734 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.76219 * group.width, y: group.minY + 0.07426 * group.height), controlPoint1: CGPoint(x: group.minX + 0.75876 * group.width, y: group.minY + 0.07662 * group.height), controlPoint2: CGPoint(x: group.minX + 0.76045 * group.width, y: group.minY + 0.07541 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.00000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.68595 * group.width, y: group.minY + 0.02721 * group.height), controlPoint2: CGPoint(x: group.minX + 0.59617 * group.width, y: group.minY + 0.00000 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.21545 * group.width, y: group.minY + 0.08895 * group.height), controlPoint1: CGPoint(x: group.minX + 0.39424 * group.width, y: group.minY + 0.00000 * group.height), controlPoint2: CGPoint(x: group.minX + 0.29622 * group.width, y: group.minY + 0.03291 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.21731 * group.width, y: group.minY + 0.09483 * group.height), controlPoint1: CGPoint(x: group.minX + 0.21588 * group.width, y: group.minY + 0.09095 * group.height), controlPoint2: CGPoint(x: group.minX + 0.21643 * group.width, y: group.minY + 0.09293 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.37022 * group.width, y: group.minY + 0.32178 * group.height), controlPoint1: CGPoint(x: group.minX + 0.25141 * group.width, y: group.minY + 0.16831 * group.height), controlPoint2: CGPoint(x: group.minX + 0.29529 * group.width, y: group.minY + 0.29303 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.47486 * group.width, y: group.minY + 0.34740 * group.height), controlPoint1: CGPoint(x: group.minX + 0.40666 * group.width, y: group.minY + 0.33574 * group.height), controlPoint2: CGPoint(x: group.minX + 0.44033 * group.width, y: group.minY + 0.33048 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.48626 * group.width, y: group.minY + 0.35679 * group.height), controlPoint1: CGPoint(x: group.minX + 0.47855 * group.width, y: group.minY + 0.34919 * group.height), controlPoint2: CGPoint(x: group.minX + 0.48395 * group.width, y: group.minY + 0.35340 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.51112 * group.width, y: group.minY + 0.42929 * group.height), controlPoint1: CGPoint(x: group.minX + 0.50381 * group.width, y: group.minY + 0.38247 * group.height), controlPoint2: CGPoint(x: group.minX + 0.49371 * group.width, y: group.minY + 0.42009 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.52684 * group.width, y: group.minY + 0.46588 * group.height), controlPoint1: CGPoint(x: group.minX + 0.52490 * group.width, y: group.minY + 0.43657 * group.height), controlPoint2: CGPoint(x: group.minX + 0.53272 * group.width, y: group.minY + 0.45145 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.57947 * group.width, y: group.minY + 0.63847 * group.height), controlPoint1: CGPoint(x: group.minX + 0.50283 * group.width, y: group.minY + 0.52481 * group.height), controlPoint2: CGPoint(x: group.minX + 0.52360 * group.width, y: group.minY + 0.59221 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.55298 * group.width, y: group.minY + 0.80571 * group.height), controlPoint1: CGPoint(x: group.minX + 0.61878 * group.width, y: group.minY + 0.67102 * group.height), controlPoint2: CGPoint(x: group.minX + 0.58605 * group.width, y: group.minY + 0.74647 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.58509 * group.width, y: group.minY + 0.84324 * group.height), controlPoint1: CGPoint(x: group.minX + 0.54116 * group.width, y: group.minY + 0.82690 * group.height), controlPoint2: CGPoint(x: group.minX + 0.56224 * group.width, y: group.minY + 0.85136 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.68578 * group.width, y: group.minY + 0.78195 * group.height), controlPoint1: CGPoint(x: group.minX + 0.62122 * group.width, y: group.minY + 0.83038 * group.height), controlPoint2: CGPoint(x: group.minX + 0.65114 * group.width, y: group.minY + 0.81174 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.79664 * group.width, y: group.minY + 0.65502 * group.height), controlPoint1: CGPoint(x: group.minX + 0.73600 * group.width, y: group.minY + 0.73876 * group.height), controlPoint2: CGPoint(x: group.minX + 0.74686 * group.width, y: group.minY + 0.69169 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.79783 * group.width, y: group.minY + 0.65347 * group.height), controlPoint1: CGPoint(x: group.minX + 0.79719 * group.width, y: group.minY + 0.65462 * group.height), controlPoint2: CGPoint(x: group.minX + 0.79760 * group.width, y: group.minY + 0.65412 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.81019 * group.width, y: group.minY + 0.51398 * group.height), controlPoint1: CGPoint(x: group.minX + 0.81055 * group.width, y: group.minY + 0.61616 * group.height), controlPoint2: CGPoint(x: group.minX + 0.85009 * group.width, y: group.minY + 0.53472 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.72267 * group.width, y: group.minY + 0.40045 * group.height), controlPoint1: CGPoint(x: group.minX + 0.77295 * group.width, y: group.minY + 0.49464 * group.height), controlPoint2: CGPoint(x: group.minX + 0.75902 * group.width, y: group.minY + 0.43862 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.70657 * group.width, y: group.minY + 0.39312 * group.height), controlPoint1: CGPoint(x: group.minX + 0.71850 * group.width, y: group.minY + 0.39607 * group.height), controlPoint2: CGPoint(x: group.minX + 0.71257 * group.width, y: group.minY + 0.39390 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.61200 * group.width, y: group.minY + 0.37603 * group.height), controlPoint1: CGPoint(x: group.minX + 0.66202 * group.width, y: group.minY + 0.38738 * group.height), controlPoint2: CGPoint(x: group.minX + 0.64198 * group.width, y: group.minY + 0.35350 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.55648 * group.width, y: group.minY + 0.35566 * group.height), controlPoint1: CGPoint(x: group.minX + 0.58955 * group.width, y: group.minY + 0.39291 * group.height), controlPoint2: CGPoint(x: group.minX + 0.56431 * group.width, y: group.minY + 0.38264 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.53328 * group.width, y: group.minY + 0.33403 * group.height), controlPoint1: CGPoint(x: group.minX + 0.55393 * group.width, y: group.minY + 0.34686 * group.height), controlPoint2: CGPoint(x: group.minX + 0.54943 * group.width, y: group.minY + 0.33902 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.51945 * group.width, y: group.minY + 0.30429 * group.height), controlPoint1: CGPoint(x: group.minX + 0.52100 * group.width, y: group.minY + 0.33026 * group.height), controlPoint2: CGPoint(x: group.minX + 0.51503 * group.width, y: group.minY + 0.31634 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.51964 * group.width, y: group.minY + 0.30376 * group.height), controlPoint1: CGPoint(x: group.minX + 0.51952 * group.width, y: group.minY + 0.30412 * group.height), controlPoint2: CGPoint(x: group.minX + 0.51957 * group.width, y: group.minY + 0.30393 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.47531 * group.width, y: group.minY + 0.29293 * group.height), controlPoint1: CGPoint(x: group.minX + 0.52555 * group.width, y: group.minY + 0.28766 * group.height), controlPoint2: CGPoint(x: group.minX + 0.49224 * group.width, y: group.minY + 0.29010 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.48138 * group.width, y: group.minY + 0.27767 * group.height), controlPoint1: CGPoint(x: group.minX + 0.47057 * group.width, y: group.minY + 0.29372 * group.height), controlPoint2: CGPoint(x: group.minX + 0.48667 * group.width, y: group.minY + 0.27457 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.43581 * group.width, y: group.minY + 0.24459 * group.height), controlPoint1: CGPoint(x: group.minX + 0.46055 * group.width, y: group.minY + 0.28997 * group.height), controlPoint2: CGPoint(x: group.minX + 0.43471 * group.width, y: group.minY + 0.26874 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.48352 * group.width, y: group.minY + 0.21643 * group.height), controlPoint1: CGPoint(x: group.minX + 0.43695 * group.width, y: group.minY + 0.22009 * group.height), controlPoint2: CGPoint(x: group.minX + 0.44152 * group.width, y: group.minY + 0.22126 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.54916 * group.width, y: group.minY + 0.26243 * group.height), controlPoint1: CGPoint(x: group.minX + 0.52872 * group.width, y: group.minY + 0.19538 * group.height), controlPoint2: CGPoint(x: group.minX + 0.55060 * group.width, y: group.minY + 0.21072 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.57845 * group.width, y: group.minY + 0.22538 * group.height), controlPoint1: CGPoint(x: group.minX + 0.57710 * group.width, y: group.minY + 0.26657 * group.height), controlPoint2: CGPoint(x: group.minX + 0.58686 * group.width, y: group.minY + 0.25422 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.58331 * group.width, y: group.minY + 0.20060 * group.height), controlPoint1: CGPoint(x: group.minX + 0.57598 * group.width, y: group.minY + 0.21695 * group.height), controlPoint2: CGPoint(x: group.minX + 0.57797 * group.width, y: group.minY + 0.20755 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.75667 * group.width, y: group.minY + 0.07734 * group.height), controlPoint1: CGPoint(x: group.minX + 0.63483 * group.width, y: group.minY + 0.13360 * group.height), controlPoint2: CGPoint(x: group.minX + 0.67784 * group.width, y: group.minY + 0.10440 * group.height))
        bezierPath.close()
        fillColor3.setFill()
        bezierPath.fill()
    }

    public dynamic class func drawLikeButton(frame: CGRect = CGRect(x: 0, y: 0, width: 512, height: 468)) {
        //// Color Declarations
        let fillColor4 = UIColor(red: 0.800, green: 0.000, blue: 0.118, alpha: 1.000)


        //// Subframes
        let group: CGRect = CGRect(x: frame.minX, y: frame.minY - 0.24, width: frame.width, height: frame.height + 0.48)


        //// Group
        //// favorite-outline
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group.minX + 0.72500 * group.width, y: group.minY + 0.00000 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.11475 * group.height), controlPoint1: CGPoint(x: group.minX + 0.64000 * group.width, y: group.minY + 0.00000 * group.height), controlPoint2: CGPoint(x: group.minX + 0.55500 * group.width, y: group.minY + 0.04372 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.27500 * group.width, y: group.minY + 0.00000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.44500 * group.width, y: group.minY + 0.04372 * group.height), controlPoint2: CGPoint(x: group.minX + 0.36000 * group.width, y: group.minY + 0.00000 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.30055 * group.height), controlPoint1: CGPoint(x: group.minX + 0.12000 * group.width, y: group.minY + 0.00000 * group.height), controlPoint2: CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.13115 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.43000 * group.width, y: group.minY + 0.92896 * group.height), controlPoint1: CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.50820 * group.height), controlPoint2: CGPoint(x: group.minX + 0.17000 * group.width, y: group.minY + 0.67760 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 1.00000 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.57000 * group.width, y: group.minY + 0.92896 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.30055 * group.height), controlPoint1: CGPoint(x: group.minX + 0.82500 * group.width, y: group.minY + 0.67213 * group.height), controlPoint2: CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.50273 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.72500 * group.width, y: group.minY + 0.00000 * group.height), controlPoint1: CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.13115 * group.height), controlPoint2: CGPoint(x: group.minX + 0.88000 * group.width, y: group.minY + 0.00000 * group.height))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: group.minX + 0.50500 * group.width, y: group.minY + 0.85246 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.85246 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.49500 * group.width, y: group.minY + 0.84699 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.10000 * group.width, y: group.minY + 0.30055 * group.height), controlPoint1: CGPoint(x: group.minX + 0.25500 * group.width, y: group.minY + 0.61202 * group.height), controlPoint2: CGPoint(x: group.minX + 0.10000 * group.width, y: group.minY + 0.45902 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.27500 * group.width, y: group.minY + 0.10929 * group.height), controlPoint1: CGPoint(x: group.minX + 0.10000 * group.width, y: group.minY + 0.19126 * group.height), controlPoint2: CGPoint(x: group.minX + 0.17500 * group.width, y: group.minY + 0.10929 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.45500 * group.width, y: group.minY + 0.24044 * group.height), controlPoint1: CGPoint(x: group.minX + 0.35000 * group.width, y: group.minY + 0.10929 * group.height), controlPoint2: CGPoint(x: group.minX + 0.42500 * group.width, y: group.minY + 0.16393 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.55000 * group.width, y: group.minY + 0.24044 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.72500 * group.width, y: group.minY + 0.10929 * group.height), controlPoint1: CGPoint(x: group.minX + 0.57500 * group.width, y: group.minY + 0.16393 * group.height), controlPoint2: CGPoint(x: group.minX + 0.65000 * group.width, y: group.minY + 0.10929 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.90000 * group.width, y: group.minY + 0.30055 * group.height), controlPoint1: CGPoint(x: group.minX + 0.82500 * group.width, y: group.minY + 0.10929 * group.height), controlPoint2: CGPoint(x: group.minX + 0.90000 * group.width, y: group.minY + 0.19126 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.50500 * group.width, y: group.minY + 0.85246 * group.height), controlPoint1: CGPoint(x: group.minX + 0.90000 * group.width, y: group.minY + 0.45902 * group.height), controlPoint2: CGPoint(x: group.minX + 0.74500 * group.width, y: group.minY + 0.61202 * group.height))
        bezierPath.close()
        fillColor4.setFill()
        bezierPath.fill()






        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: frame.minX + 512, y: frame.minY + 140.6))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 291.8, y: frame.minY + 435), controlPoint1: CGPoint(x: frame.minX + 512, y: frame.minY + 235.3), controlPoint2: CGPoint(x: frame.minX + 422.4, y: frame.minY + 314.7))
        bezier2Path.addLine(to: CGPoint(x: 256, y: 469.2))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 220.2, y: frame.minY + 435))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX, y: frame.minY + 140.6), controlPoint1: CGPoint(x: frame.minX + 87, y: frame.minY + 317.2), controlPoint2: CGPoint(x: frame.minX, y: frame.minY + 237.8))
        bezier2Path.addCurve(to: CGPoint(x: 140.8, y: 0.8), controlPoint1: CGPoint(x: frame.minX, y: frame.minY + 61.2), controlPoint2: CGPoint(x: 61.4, y: 0.8))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 256, y: frame.minY + 53.6), controlPoint1: CGPoint(x: 184.3, y: 0.8), controlPoint2: CGPoint(x: frame.minX + 227.8, y: frame.minY + 20.3))
        bezier2Path.addCurve(to: CGPoint(x: 371.2, y: 0.8), controlPoint1: CGPoint(x: frame.minX + 284.2, y: frame.minY + 20.3), controlPoint2: CGPoint(x: 327.7, y: 0.8))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 512, y: frame.minY + 140.6), controlPoint1: CGPoint(x: 450.6, y: 0.8), controlPoint2: CGPoint(x: frame.minX + 512, y: frame.minY + 61.2))
        bezier2Path.close()
        fillColor4.setFill()
        bezier2Path.fill()
    }

    public dynamic class func drawLikeButtonFilled(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 512, height: 468), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 512, height: 468), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 512, y: resizedFrame.height / 468)


        //// Color Declarations
        let fillColor4 = UIColor(red: 0.800, green: 0.000, blue: 0.118, alpha: 1.000)

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 512, y: 140.6))
        bezierPath.addCurve(to: CGPoint(x: 291.8, y: 435), controlPoint1: CGPoint(x: 512, y: 235.3), controlPoint2: CGPoint(x: 422.4, y: 314.7))
        bezierPath.addLine(to: CGPoint(x: 256, y: 468.2))
        bezierPath.addLine(to: CGPoint(x: 220.2, y: 435))
        bezierPath.addCurve(to: CGPoint(x: 0, y: 140.6), controlPoint1: CGPoint(x: 87, y: 317.2), controlPoint2: CGPoint(x: 0, y: 237.8))
        bezierPath.addCurve(to: CGPoint(x: 140.8, y: -0.2), controlPoint1: CGPoint(x: 0, y: 61.2), controlPoint2: CGPoint(x: 61.4, y: -0.2))
        bezierPath.addCurve(to: CGPoint(x: 256, y: 53.6), controlPoint1: CGPoint(x: 184.3, y: -0.2), controlPoint2: CGPoint(x: 227.8, y: 20.3))
        bezierPath.addCurve(to: CGPoint(x: 371.2, y: -0.2), controlPoint1: CGPoint(x: 284.2, y: 20.3), controlPoint2: CGPoint(x: 327.7, y: -0.2))
        bezierPath.addCurve(to: CGPoint(x: 512, y: 140.6), controlPoint1: CGPoint(x: 450.6, y: -0.2), controlPoint2: CGPoint(x: 512, y: 61.2))
        bezierPath.close()
        fillColor4.setFill()
        bezierPath.fill()
        
        context.restoreGState()

    }

    //// Generated Images

    public dynamic class var imageOfTextLogo: UIImage {
        if Cache.imageOfTextLogo != nil {
            return Cache.imageOfTextLogo!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 130, height: 53), false, 0)
            HijinnksStyleKit.drawTextLogo()

        Cache.imageOfTextLogo = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfTextLogo!
    }

    //// Customization Infrastructure

    @IBOutlet dynamic var textLogoTargets: [AnyObject]! {
        get { return Cache.textLogoTargets }
        set {
            Cache.textLogoTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: HijinnksStyleKit.imageOfTextLogo)
            }
        }
    }




    @objc public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
